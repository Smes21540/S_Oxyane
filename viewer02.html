

<!DOCTYPE html>
<html lang="fr">
<head>
  <!-- === PARTIE 1 : DOCTYPE + HEAD (Librairies) === -->
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Courbes</title>

  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåΩ</text></svg>">


  <!-- Librairies -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

  <!-- === PARTIE 2 : Styles CSS === -->
  <style>
    :root{
      --bg:#fff5f5; --panel:#ffffff; --accent:#ff7043; --accent-darker:#e64a19;
      --accent-muted:#ffccbc; --danger:#d84315; --text:#333; --shadow:rgba(0,0,0,0.1);
    }

    /* Base */
    body{
      font-family:"Segoe UI",Tahoma,Geneva,Verdana,sans-serif;
      background:var(--bg); margin:0; padding:5px 20px; color:var(--danger);
      display:flex; flex-direction:column; min-height:100vh;
    }

    /* Header */
    .header{position:relative;display:flex;align-items:center;justify-content:center;margin-bottom:10px;}
    .header .logo{height:60px;width:auto;}
    #fileNameContainer{position:absolute;right:0;top:0;text-align:right;}
    #fileName,#lineCount{color:var(--accent-darker);}
    #fileName{font-size:24px;font-weight:bold;white-space:nowrap;max-width:300px;overflow:hidden;text-overflow:ellipsis;display:none;}
    #lineCount{font-size:12px;display:none;}

    /* Barre de contr√¥les */
    .controls{
      display:flex; justify-content:center; align-items:center;
      gap:10px; margin-bottom:10px; flex-wrap:wrap;
    }
    button{
      background:var(--accent); color:#fff; border:none; cursor:pointer;
      font-weight:bold; padding:8px 12px; border-radius:6px; font-size:13px;
      transition:background-color .3s, transform .2s;
    }
    button:hover{background:var(--accent-darker);transform:scale(1.05);}
    button:disabled{background:#ccc;color:#666;cursor:not-allowed;transform:none;}

    /* ‚öôÔ∏è Garantit des boutons compacts dans la barre de contr√¥le */
    .controls button{flex:0 0 auto; width:auto; display:inline-block;}

    /* Zone graphe */
.graph-wrapper {
  display: flex;
  align-items: stretch;   /* le canvas prend toute la hauteur */
  justify-content: center;
  gap: 20px;
  margin-bottom: 40px;
  height: 1000px;          /* hauteur fix√©e comme le canvas */
}

.graph-side {
  display: flex;
  flex-direction: column;
  justify-content: center; /* centre verticalement si le menu est plus petit */
}

#myChart {
  width: 100%;
  aspect-ratio: 16/9;
  max-height: 1000px;
  background: #fff;
  border-radius: 8px;
  box-shadow: 0 4px 12px var(--shadow);
  display: block;
  margin: 0 auto;
}

.y-columns {
  display: flex;
  flex-direction: column;
  gap: 4px;

  /* hauteur adaptative */
  max-height: 1000px;      /* ne jamais d√©passer 1000px */
  height: auto;            /* prend la taille du contenu si < 1000px */

  overflow-y: auto;        /* ajoute une barre de d√©filement si trop long */
  border: 1px solid #ddd;
  padding: 6px;
  border-radius: 6px;
  background: var(--panel);
  scrollbar-width: thin;
  width: 220px;
}




    /* Infos & √©tats */
    #zoomInfo{
      position:absolute; top:80px; right:20px; background:rgba(255,255,255,0.9);
      border:1px solid var(--accent); border-radius:6px; padding:6px 10px; font-size:12px;
      color:var(--accent-darker); font-weight:bold; z-index:10; pointer-events:none;
    }
#spinner {
  display: none;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  z-index: 2000;
}

.spin-inner {
  width: 50px;
  height: 50px;
  border: 6px solid #ccc;
  border-top: 6px solid var(--accent);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to   { transform: rotate(360deg); }
}

    #errorBox{
      display:none;position:fixed;top:40%;left:50%;transform:translate(-50%,-50%);
      background:var(--accent-muted);padding:20px;border-radius:10px;box-shadow:0 4px 12px rgba(0,0,0,0.2);
      z-index:2001;text-align:center;color:var(--danger);font-weight:bold;
    }

    /* Menu th√®mes */
    #secretBtn{position:fixed;bottom:10px;right:10px;width:25px;height:25px;opacity:0;cursor:pointer;z-index:2000;}
    #themeMenu{
      display:none;position:fixed;bottom:50px;right:10px;background:var(--panel);
      border:2px solid var(--accent);border-radius:8px;box-shadow:0 4px 12px var(--shadow);
      padding:10px;z-index:2001;min-width:150px;
    }
    #themeMenu h3{margin:0 0 8px 0;font-size:14px;color:var(--accent);}
    #themeMenu .closeMenu{position:absolute;top:5px;right:8px;font-size:14px;cursor:pointer;color:var(--accent);}
    #themeMenu .closeMenu:hover{color:var(--accent-darker);}
    #themeMenu button{display:block; width:100%; margin:4px 0; padding:6px; border:none; border-radius:6px;
      background:var(--accent); color:#fff; cursor:pointer; font-size:13px;}
    #themeMenu button:hover{background:var(--accent-darker);}

    /* Modal jours */
    #dayModal{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--panel);
      border:2px solid var(--accent);border-radius:10px;box-shadow:0 4px 12px var(--shadow);
      padding:20px;z-index:3000;text-align:center;min-width:270px;}
    #dayModal h3{margin:0;color:var(--accent);font-size:16px;}
    #dayModal input{width:80px;text-align:center;padding:6px;margin:15px 0;font-size:15px;border:1px solid #ddd;border-radius:6px;}
    #dayModal .actions{margin-top:14px;display:flex;justify-content:center;gap:10px;}
    #dayModal button{margin:0;padding:8px 12px;border-radius:6px;}
    #dayModal .ghost{background:#eee;color:#333;}

    /* S√©lecteurs colonnes */
    @media (max-width:600px){#myChart{width:100%;}}
.y-columns {
  display: flex;
  flex-direction: column;
  gap: 4px;

  /* hauteur auto sauf si trop long */
  height: auto;            /* s'adapte au contenu */
  max-height: 1000px;      /* plafonn√© √† 1000px si trop grand */
  overflow-y: auto;        /* active le scroll uniquement si n√©cessaire */

  border: 1px solid #ddd;
  padding: 6px;
  border-radius: 6px;
  background: var(--panel);
  scrollbar-width: thin;
  width: 220px;
}

    
    .y-columns::-webkit-scrollbar{width:6px;}
    .y-columns::-webkit-scrollbar-thumb{background:var(--accent);border-radius:4px;}
    .y-columns::-webkit-scrollbar-track{background:#f0f0f0;}

    .y-columns label{
      display:flex; align-items:center; gap:6px; padding:4px 6px; border-radius:4px; cursor:pointer;
      font-size:13px; background:var(--accent-muted); user-select:none; white-space:nowrap; justify-content:flex-start;
    }
    .y-columns input[type="checkbox"]{accent-color:var(--accent);}

    /* Petite mise au point pour le conteneur des s√©lecteurs */
    #columnSelectors{align-items:center;}

/* üîí Masquer les boutons "avant/apr√®s" et "√©tendre" */
#extendPrev,
#extendNext,
#panPrev,
#panNext {
  display: none !important;
}

/* Positionnement du bloc √† gauche du graphe */
.graph-side {
  display: flex;
  flex-direction: column;
  justify-content: center; /* centre verticalement */
  align-items: center;     /* centre horizontalement */
}

    #currentFolderName {
      position: absolute;
      left: 10px;
      top: 10px;
      font-size: 22px;           /* assez gros */
      font-weight: bold;
      color: var(--accent);      /* couleur du th√®me */
      white-space: nowrap;
      max-width: 500px;          /* limite largeur */
      overflow: hidden;
      text-overflow: ellipsis;
    }

/* Effet flamme anim√©e */
.flame {
  display: inline-block;
  animation: flicker 1s infinite alternate;
}
@keyframes flicker {
  0%   { transform: scale(1) rotate(0deg); opacity: 1; }
  25%  { transform: scale(1.1) rotate(-5deg); opacity: 0.9; }
  50%  { transform: scale(0.9) rotate(5deg); opacity: 0.8; }
  75%  { transform: scale(1.05) rotate(-3deg); opacity: 1; }
  100% { transform: scale(1) rotate(0deg); opacity: 0.95; }
}

/* Bouton flottant */
#noteButton {
  position: fixed;
  bottom: 20px;
  right: 20px;
  background: var(--accent);
  color: var(--accent-contrast);
  border-radius: 50%;
  width: 46px;
  height: 46px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  cursor: pointer;
  box-shadow: 0 3px 8px rgba(0,0,0,0.25);
  transition: transform 0.2s;
  z-index: 1200;
}
#noteButton:hover {
  transform: scale(1.1);
  background: var(--accent-darker);
}

/* Popup de note */
#notePopup {
  display: none;
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.6);
  z-index: 2000;
  justify-content: center;
  align-items: center;
}

#notePopup.active {
  display: flex;
}

.note-content {
  background: var(--panel);
  color: var(--text);
  padding: 20px;
  border-radius: 10px;
  width: 400px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
}

.note-content h3 {
  margin-top: 0;
  color: var(--accent);
}

#noteText {
  width: 100%;
  height: 120px;
  border: 1px solid var(--table-border);
  border-radius: 6px;
  padding: 8px;
  resize: vertical;
  font-size: 14px;
}

.note-actions {
  margin-top: 10px;
  text-align: right;
}

.note-actions button {
  background: var(--accent);
  color: #fff;
  border: none;
  padding: 6px 12px;
  border-radius: 6px;
  font-weight: bold;
  cursor: pointer;
  margin-left: 6px;
}

.note-actions button:hover {
  background: var(--accent-darker);
}

#noteStatus {
  margin-top: 8px;
  font-size: 12px;
  color: var(--muted-text);
}

.loader {
  border: 4px solid #fff;
  border-top: 4px solid transparent;
  border-radius: 50%;
  width: 30px;
  height: 30px;
  margin-right: 12px;
  animation: spin 0.7s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}


@keyframes pulse {
  0% { opacity: 0.6; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
}

    

  </style>
</head>
<body>
  <!-- === PARTIE 3 : Header === -->
<div class="header">
  <div id="currentFolderName"></div> <!-- üí° nouveau bloc pour le dossier -->
  <img src="img/logo.png" alt="Logo" class="logo" />
  <div id="fileNameContainer">
    <div id="fileName"></div>
    <div id="lineCount"></div>
  </div>
</div>


  <!-- === PARTIE 4 : Contr√¥les === -->
  <div class="controls">
    <button id="backBtn">‚¨ÖÔ∏è Retour</button>
    <button id="exportPDF" style="display:none;">üìÑ Exporter PDF</button>
    <button id="resetZoom" style="display:none;">üîÑ R√©initialiser zoom</button>
    <button id="smoothBtn" style="display:none;" title="Active un lissage visuel de la courbe">‚ú® Lissage OFF</button>
    <button id="avgModeBtn" style="display:none;" title="Calculer une moyenne entre 2 points">üìê Moyenne</button>
    <button id="toggleZ3" style="display:none;"
        title="Affiche ou masque les √©v√©nements d√©tect√©s">üö® √âv√©nements Z3 OFF</button>

    <button id="toggleNotes" style="display:none;"
        title="Affiche les notes associ√©es √† cette journ√©e">üóíÔ∏è Notes ON</button>

    <button id="filterParasites" style="display:none;" title="Active ou d√©sactive le filtre des valeurs parasites">üßπ Parasites OFF</button>



  </div>

  <!-- === PARTIE 5 : S√©lecteurs === -->
  <div class="controls" id="columnSelectors" style="display:none; flex-direction:column; gap:8px;">
    <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
      <select id="xColumn"></select>
      <button id="drawChartBtn" style="display:none;">üìä Afficher courbes</button>
    </div>
    <!-- Cases √† cocher pour les colonnes Y -->
    
  </div>

<!-- === PARTIE 6 : Zone Graphique === -->
<div class="graph-wrapper">
  <!-- C√¥t√© gauche : menu Y -->
  <div class="graph-side">
    <div id="yColumnsContainer" class="y-columns"></div>
  </div>

  <!-- Zone centrale : graphe -->
  <div style="flex:1; display:flex; flex-direction:column; align-items:center;">
    <canvas id="myChart" width="1400" height="1000"></canvas>
    <input type="color" id="colorPicker" style="display:none;" />
    <div id="dateLabels" style="text-align:center; margin-top:8px; font-weight:bold; color:var(--danger);"></div>
  </div>
</div>



  <!-- === PARTIE 7 : Aides/√©tats === -->
  <div id="zoomInfo">üîç S√©lectionner une zone (drag) pour zoomer, molette+Ctrl pour zoom, Ctrl+clic sur la courbe pour changer sa couleur</div>
 <div id="spinner">
  <div class="spin-inner"></div>
</div>

  <div id="errorBox">
    ‚ö†Ô∏è Impossible de charger le fichier.<br>V√©rifiez la connexion ou r√©essayez plus tard.<br><br>
    <button onclick="window.location.reload()">R√©essayer</button>
  </div>

  <!-- === PARTIE 8 : Menu Th√®mes === -->
  <div id="secretBtn" title=" "></div>
  <div id="themeMenu">
    <span class="closeMenu" onclick="closeThemeMenu()">‚ùå</span>
    <h3>Choisir un th√®me</h3>
    <button onclick="setTheme('orange')">Orange (d√©faut)</button>
    <button onclick="setTheme('blue')">Bleu</button>
    <button onclick="setTheme('green')">Vert</button>
    <button onclick="setTheme('purple')">Violet</button>
    <button onclick="setTheme('bordeaux')">Bordeaux</button>
  </div>

  <!-- === PARTIE 9 : Modal jours === -->
  <div id="dayModal" role="dialog" aria-modal="true" aria-labelledby="dayModalTitle">
    <h3 id="dayModalTitle">Combien de jours souhaitez-vous charger&nbsp;?</h3>
    <input type="number" id="dayCount" value="1" min="1" />
    <div class="actions">
      <button id="confirmDay">OK</button>
      <button class="ghost" onclick="closeDayModal()">Annuler</button>
    </div>
  </div>

  <script>
  /* ===================== CONFIG / STATE ===================== */
    let csvData=[], chart, currentX="", currentY=[];
    let notesData = []; // üóíÔ∏è Liste des notes actives √† afficher sur le graphe
    let currentFolderId = null; // üß© dossier actuel du CSV
    let currentFolderPath = ""; // üÜï texte lisible du dossier courant


  let baseFileName="", baseFileId="", headers=[], timeField="", baseDateYYYYMMDD="";
  let colors=[]; let themeMenuTimer;
  let loadedDays=new Set(); let saMeta=null;
  let customColors = {}; // m√©morise les couleurs choisies par label
  let initialMin = null, initialMax = null;

let avgState = "idle";  // idle | first | second
let avgStart = null;
   let avgMode = false; 


  // Z3
  let z3Events = []; // {time: Date, label: string}
  let z3Visible = false;
    let notesVisible = true;





  /* ===================== THEME ===================== */
function applyThemeVars(vars){
  const r=document.documentElement;
  Object.entries(vars).forEach(([k,v])=>r.style.setProperty(k,v));
  colors = buildPalette();
  if(chart){
    chart.data.datasets.forEach((ds,i)=>{
      const baseLabel = ds.label.replace(" (liss√©)", "");
      const saved = customColors[baseLabel];
      const c = saved || colors[i % colors.length];
      ds.borderColor = c;
      ds.backgroundColor = c;
      ds.pointBackgroundColor = c;
      ds.pointBorderColor = c;
    });
    chart.update('none');
  }
}

  
  function setTheme(theme){
    localStorage.setItem("selectedTheme",theme);
    if(theme==="orange") applyThemeVars({"--accent":"#ff7043","--accent-darker":"#e64a19","--accent-muted":"#ffccbc","--bg":"#fff5f5","--panel":"#ffffff","--danger":"#d84315","--text":"#333"});
    if(theme==="blue")   applyThemeVars({"--accent":"#2196f3","--accent-darker":"#1976d2","--accent-muted":"#bbdefb","--bg":"#e3f2fd","--panel":"#ffffff","--danger":"#0d47a1","--text":"#0d47a1"});
    if(theme==="green")  applyThemeVars({"--accent":"#4caf50","--accent-darker":"#2e7d32","--accent-muted":"#c8e6c9","--bg":"#f1f8e9","--panel":"#ffffff","--danger":"#1b5e20","--text":"#1b5e20"});
    if(theme==="purple") applyThemeVars({"--accent":"#9c27b0","--accent-darker":"#6a1b9a","--accent-muted":"#e1bee7","--bg":"#f3e5f5","--panel":"#ffffff","--danger":"#4a148c","--text":"#4a148c"});
    if(theme==="bordeaux")applyThemeVars({"--accent":"#800020","--accent-darker":"#4b0014","--accent-muted":"#d7a1a9","--bg":"#fff0f2","--panel":"#ffffff","--danger":"#600018","--text":"#4b0014"});
  }
  document.getElementById("secretBtn").onclick=()=>{
    const m=document.getElementById("themeMenu");
    if(m.style.display==="block"){closeThemeMenu();}else{m.style.display="block";resetThemeMenuTimer();}
  };
  function resetThemeMenuTimer(){clearTimeout(themeMenuTimer);themeMenuTimer=setTimeout(closeThemeMenu,10000);}
  function closeThemeMenu(){document.getElementById("themeMenu").style.display="none";clearTimeout(themeMenuTimer);}
  function getCSSVar(v){return getComputedStyle(document.documentElement).getPropertyValue(v).trim();}
  function hexToRgb(hex){hex=hex.replace('#','');if(hex.length===3){hex=hex.split('').map(h=>h+h).join('');}const n=parseInt(hex,16);return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};}
  function buildPalette(){const a=getCSSVar('--accent'),d=getCSSVar('--danger');return [a,d,"#3380ff","#4caf50","#8e44ad","#ff33a6","#33cccc","#ffc300"];}

  /* ===================== SPINNER + ERROR ===================== */
  function showSpinner(){document.getElementById('spinner').style.display='block';}
  function hideSpinner(){document.getElementById('spinner').style.display='none';}
  function showError(){hideSpinner();document.getElementById('errorBox').style.display='block';}

  /* ===================== UTILS ===================== */
  function getParam(n){return new URLSearchParams(window.location.search).get(n);}
  function parseSAFileName(fname){const m=fname.match(/^SA(\d+)_(\d{8})/i);if(!m) return null;return {num:m[1].padStart(5,"0"),date:m[2]};}
  function shiftDate(yyyymmdd,delta){
    const y=+yyyymmdd.slice(0,4), m=+yyyymmdd.slice(4,6)-1, d=+yyyymmdd.slice(6,8);
    const dt=new Date(y,m,d); dt.setDate(dt.getDate()+delta);
    return dt.getFullYear()+String(dt.getMonth()+1).padStart(2,"0")+String(dt.getDate()).padStart(2,"0");
  }
  function makeSortKey(iso,t){return new Date(`${iso}T${t||"00:00:00"}`).getTime();}
  function dedupeHeaders(arr) {
    const hc = {};
    return arr.map(h => {
      const k = (h == null ? "" : String(h));
      hc[k] = (hc[k] || 0) + 1;
      const upperK = k.toUpperCase();
      if (upperK.includes("SONDE") || upperK.includes("TEMP")) {
        if (hc[k] === 1) return `${k} Consigne`;
        if (hc[k] === 2) return `${k} Valeur`;
        return `${k}_${hc[k]}`;
      }
      return hc[k] === 1 ? k : `${k}_${hc[k]}`;
    });
  }
  function capitalizeFirst(s){return s? s.charAt(0).toUpperCase()+s.slice(1):s;}
  function dayLabelFR(ts){
    const nd=new Date(ts);
    return capitalizeFirst(nd.toLocaleDateString('fr-FR',{weekday:'long',day:'numeric',month:'long',year:'numeric'}));
  }

// === AJOUT (pas d'AVANT) : couleur d√©terministe par auteur ===
function hashStr(s){
  s = String(s||"");
  let h = 0;
  for (let i=0;i<s.length;i++){ h = (h*31 + s.charCodeAt(i))|0; }
  return Math.abs(h);
}
function colorFromAuthor(name){
  const palette = ["#ff7043","#e64a19","#3380ff","#4caf50","#8e44ad","#ff33a6","#33cccc","#ffc300"];
  const h = hashStr(name);
  return palette[h % palette.length];
}

function resetAvgCycle() {
  avgMode = false;
  avgState = "idle";
  avgStart = null;
  highlightAvgBtn(false);
}



function highlightAvgBtn(active) {
  const b = document.getElementById("avgModeBtn");
  if (active) {
    b.style.background = "red";
    b.style.animation = "pulse 0.7s infinite";
  } else {
    b.style.background = getCSSVar("--accent");
    b.style.animation = "";
  }
}




    

  /* ===================== FETCH CSV ===================== */
// üîí Version s√©curis√©e ‚Äî plus de cl√© API expos√©e
async function loadCSVByFileId(fileId){
  try{
    showSpinner();
    // ‚úÖ Utilisation du proxy Netlify s√©curis√©
    const url = `https://smes21540.netlify.app/.netlify/functions/drive?id=${fileId}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = new TextDecoder('windows-1252').decode(await res.arrayBuffer());
    hideSpinner();
    return Papa.parse(text, { header: false, dynamicTyping: true, skipEmptyLines: true });
  } catch (e) {
    console.error(e);
    showError();
    return null;
  }
}

  function buildObjectsFromParsedResults(results,hdrs){
    return results.data.slice(1).map(row=>{const o={};row.forEach((v,i)=>o[hdrs[i]]=v);return o;});
  }
  function enrichRowsWithDate(rows,yyyymmdd){
    if(!timeField) return rows;
    const iso=`${yyyymmdd.slice(0,4)}-${yyyymmdd.slice(4,6)}-${yyyymmdd.slice(6,8)}`;
    rows.forEach(r=>{r.__dateISO=iso;r.__sortKey=makeSortKey(iso,r[timeField]);});
    return rows;
  }

  /* ===================== LOAD CSV (base) ===================== */
async function loadCSVFromDrive(){
  baseFileId = getParam('fileId'); 
  baseFileName = decodeURIComponent(getParam('fileName')||'');
  if(!baseFileId){showError();return;}

  document.getElementById('fileName').textContent = baseFileName;
  document.getElementById('fileName').style.display = "block";
  document.getElementById('lineCount').style.display = "block";
  document.getElementById('exportPDF').style.display = "inline-block";
  document.getElementById('resetZoom').style.display = "inline-block";

// üíæ D√©termination du dossier courant + chemin complet (identique √† index03)
try {
  const list = JSON.parse(localStorage.getItem("csvFilesList") || "[]");
  const f = list.find(x => x.id === baseFileId);

  // üîπ Trouver l'ID du dossier parent
  if (f && Array.isArray(f.parents) && f.parents.length > 0) {
    currentFolderId = f.parents[0];
  } else {
    currentFolderId = localStorage.getItem("lastFolderId") || null;
  }

  // üîπ Retrouver le dossier parent pour le nom
  const folderObj = list.find(x => x.id === currentFolderId);
  let folderName = folderObj ? folderObj.name : "(Dossier inconnu)";

  // üîπ R√©cup√©rer chemin complet du dossier
  let folderPath =
    getParam("folderPath") ||
    localStorage.getItem("currentFolderPath") ||
    folderName;

  // üîπ On anime les flammes üî•
  const flameTitle = folderPath.replace(
    /üî•/g,
    '<span class="flame" title="Br√ªleur(s) en fonctionnement">üî•</span>'
  );

  const el = document.getElementById("currentFolderName");
  if (el) el.innerHTML = flameTitle;

  // üîπ Maj du titre
  document.title = `Courbes ‚Äì ${folderName}`;

  // üîπ M√©morisation globale
  currentFolderPath = folderPath;
  localStorage.setItem("currentFolderPath", folderPath);


  console.log("[Viewer02] Dossier affich√© :", folderPath);
} catch (e) {
  console.warn("‚ö†Ô∏è Erreur r√©cup√©ration dossier courant :", e);
}







// üîπ R√©cup√©ration du chemin complet du dossier
let folderPath = new URLSearchParams(window.location.search).get("folderPath");

// üîπ Si pas trouv√© dans l‚ÄôURL (ou test local), on le reprend du localStorage
if (!folderPath || folderPath.trim() === "") {
  folderPath = localStorage.getItem("currentFolderPath") || "";
}

// üîπ Pour v√©rif
console.log("[Viewer02] Chemin dossier r√©cup√©r√© :", folderPath);

// üîπ On synchronise la variable globale
currentFolderPath = folderPath;


  






  const parsed = await loadCSVByFileId(baseFileId); 
  if(!parsed) return;
  headers = dedupeHeaders(parsed.data[0]||[]);
  csvData = buildObjectsFromParsedResults(parsed,headers);
  document.getElementById('lineCount').textContent = csvData.length+" ligne"+(csvData.length>1?"s":"");

  const xSel = document.getElementById('xColumn');
  xSel.innerHTML = "";

  // vide et reconstruit le conteneur Y
  const yContainer = document.getElementById("yColumnsContainer");
  yContainer.innerHTML = "";

  let defX = headers.find(h=>h.toLowerCase().includes("time")||h.toLowerCase()==="heure");

headers.forEach((f,i)=>{
  // X : on ajoute toutes les colonnes
  const ox = document.createElement("option");
  ox.value = f;
  ox.text = f;
  xSel.appendChild(ox);

  // Y : on saute la colonne temps
  if (f === defX || /time|date|jour/.test(f.toLowerCase())) return;

  // üîπ coche automatiquement SONDE AC INF / SUP
  const checkedByDefault =
    f.toUpperCase().includes("SONDE AC INF") ||
    f.toUpperCase().includes("SONDE AC SUP");

  const label = document.createElement("label");
  label.innerHTML = `<input type="checkbox" value="${f}" ${checkedByDefault ? "checked" : ""}> ${f}`;
  yContainer.appendChild(label);
});

// === afficher les s√©lecteurs ===
document.getElementById('columnSelectors').style.display = "flex";

if (defX) {
  xSel.value = defX;
  xSel.style.display = "none";
  timeField = defX;
}

// === apr√®s l‚Äôenrichissement, tracer automatiquement les bonnes colonnes ===
setTimeout(() => {
  currentX = defX;
  currentY = Array.from(document.querySelectorAll("#yColumnsContainer input:checked")).map(cb => cb.value);

  if (currentY.length && csvData.length && timeField) {
    drawChart();
  }
}, 300);


  saMeta = parseSAFileName(baseFileName);
  if(saMeta){
    baseDateYYYYMMDD = saMeta.date;
    enrichRowsWithDate(csvData,baseDateYYYYMMDD);
    loadedDays.add(baseDateYYYYMMDD);
  }
}


  /* ===================== CHART ===================== */
  function getTimeUnit(range){
    const d=86400000;
    if(range<=d) return {unit:'hour',stepSize:2};
    if(range<=3*d) return {unit:'hour',stepSize:6};
    if(range>=7*d) return {unit:'day',stepSize:1};
    return {unit:'hour',stepSize:4};
  }
  function applyAdaptiveTicks(){
    if(!chart) return;
    const range=chart.scales.x.max-chart.scales.x.min;
    const cfg=getTimeUnit(range);
    chart.options.scales.x.time=chart.options.scales.x.time||{};
    chart.options.scales.x.time.unit=cfg.unit;
    chart.options.scales.x.time.stepSize=cfg.stepSize;
    chart.options.scales.x.ticks.callback=(value)=>{
      const d=new Date(value);return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
    };
    chart.update('none');
  }

  // === LISSAGE : fonction de moyenne glissante
  function movingAverage(data, windowSize=10) {
    if (!data.length) return [];
    const result = [];
    const half = Math.floor(windowSize/2);
    for (let i=0; i<data.length; i++) {
      let sum = 0, count = 0;
      for (let j=i-half; j<=i+half; j++) {
        if (j>=0 && j<data.length) {
          sum += data[j].y; count++;
        }
      }
      result.push({ x: data[i].x, y: sum/count });
    }
    return result;
  }

/* ====== FILTRE VALEURS PARASITES ====== */
let parasiteFilterEnabled = false;

function filterParasites(points) {
  if (!points.length) return points;

  const filtered = [];
  const win = 5;              // m√©diane centr√©e 5 points
  const half = Math.floor(win / 2);
  const threshold = 0.10;      // 10 %

  for (let i = 0; i < points.length; i++) {
    const p = points[i];

    // üîí Prot√©ger 0 ‚Üí valeur ou valeur ‚Üí 0
    const prev = points[i - 1]?.y;
    const next = points[i + 1]?.y;

    const isZeroJump =
      (prev === 0 && p.y !== 0) ||
      (p.y !== 0 && next === 0);

    if (isZeroJump) {
      filtered.push(p);
      continue;
    }

    // Calcul m√©diane locale
    const local = [];
    for (let j = i - half; j <= i + half; j++) {
      if (j >= 0 && j < points.length && points[j].y !== 0) {
        local.push(points[j].y);
      }
    }

    if (local.length < 3) {
      filtered.push(p);
      continue;
    }

    const med = local.sort((a, b) => a - b)[Math.floor(local.length / 2)];

    // Test parasite
    const diff = Math.abs(p.y - med) / med;

    if (diff <= threshold) {
      filtered.push(p);
    }
    // sinon : √©limin√© (parasite)
  }

  return filtered;
}


    
  // === LISSAGE : buildDatasets avec m√©morisation
  function buildDatasets(){
    const smooth = localStorage.getItem("smooth") === "1";
    return currentY.map((yCol,i)=>{
      // valeurs brutes
      let pts = csvData.map(r=> {
        const x = r.__sortKey;
        const y = r[yCol];
        return (Number.isFinite(x) && typeof y === 'number') ? {x,y} : null;
      }).filter(Boolean);

      // üîç Filtre parasites
if (parasiteFilterEnabled) {
  pts = filterParasites(pts);
}


      

      

      // valeurs affich√©es
      if (smooth) pts = movingAverage(pts, 10);

const baseLabel = yCol; // la "cl√©" toujours sans (liss√©)
const savedColor = customColors[baseLabel];
const c = savedColor || colors[i % colors.length];

return {
  id: yCol,
  label: baseLabel + (smooth ? " (liss√©)" : ""),
  data: pts,
  borderColor: c,
  backgroundColor: c,
  borderWidth: 2,
  fill: false,
  tension: 0,
  pointRadius: 0,
  pointHoverRadius: 5,
  pointHitRadius: 8
};

    });
  }

  // Plugin fond altern√© par jour + labels dates
  const dayBackgroundPlugin={
    id:'dayBackground',
    beforeDraw(chart){
      const {scales:{x},chartArea}=chart;
      if(!x||!isFinite(x.min)||!isFinite(x.max)) return;
      const oneDay=86400000;
      let start=new Date(x.min); start.setHours(0,0,0,0);
      let toggle=false;
      const ctx=chart.ctx; ctx.save();

      for(let d=start.getTime(); d<x.max; d+=oneDay){
        const from=x.getPixelForValue(d), to=x.getPixelForValue(d+oneDay);
        ctx.fillStyle=toggle? (getCSSVar('--accent-muted')||'rgba(255,112,67,0.12)') : 'rgba(0,0,0,0.02)';
        ctx.fillRect(from, chartArea.top, to-from, chartArea.bottom-chartArea.top);
        toggle=!toggle;
      }
      ctx.restore();

      const labels=[];
      for(let d=start.getTime(); d<x.max; d+=oneDay){labels.push(dayLabelFR(d));}
      const dl=document.getElementById('dateLabels'); if(dl) dl.textContent = labels.join(" | ");
    }
  };

// Plugin lignes Z3 : traits fins pleins, gras au survol
const z3LinesPlugin = {
  id: 'z3Lines',
  afterDatasetsDraw(chartArg) {
    if (!z3Visible || !z3Events.length) return;
    const xScale = chartArg.scales.x;
    const { top, bottom } = chartArg.chartArea;
    const ctx = chartArg.ctx;
    ctx.save();

    // Gestion survol souris ‚Üí trouver la ligne la plus proche
    const mouse = chartArg.$z3Mouse;
    let nearest = null;
    let dist = Infinity;

    if (mouse) {
      z3Events.forEach(ev => {
        const x = xScale.getPixelForValue(ev.time.getTime());
        const d = Math.abs(mouse.x - x);
        if (d < dist) {
          nearest = { ev, x };
          dist = d;
        }
      });
      if (dist > 6) nearest = null; // seuil max
    }

    // Dessiner toutes les lignes
    z3Events.forEach(ev => {
      const x = xScale.getPixelForValue(ev.time.getTime());
      if (x < xScale.left || x > xScale.right) return;

      let color = '#003366';
      const label = ev.label.toLowerCase();
      if (label.includes('d√©faut') || label.includes('defaut') || 
          label.includes('arr√™t')  || label.includes('arret')) {
        color = 'red';
      } else if (label.includes('d√©marrage')) {
        color = 'green';
      }

      const isHovered = nearest && nearest.ev === ev;
      ctx.strokeStyle = color;
      ctx.lineWidth = isHovered ? 3 : 0.5; // √©paisseur dynamique

      ctx.beginPath();
      ctx.moveTo(x, top);
      ctx.lineTo(x, bottom);
      ctx.stroke();
    });

    // Tooltip uniquement sur la ligne survol√©e
    if (nearest) {
      const { ev, x } = nearest;
      const tooltipY = top + 25;
      const h = String(ev.time.getHours()).padStart(2,'0')+":"+String(ev.time.getMinutes()).padStart(2,'0');
      const line1 = `‚è∞ ${h}`;
      const line2 = ev.label;
      const line3 = ev.address ? `üìç ${ev.address}` : "";
      ctx.font = '12px sans-serif';
      const w = Math.max(
        ctx.measureText(line1).width,
        ctx.measureText(line2).width,
        ctx.measureText(line3).width
      ) + 14;
      const panel = getCSSVar('--panel') || '#fff';
      const accent = getCSSVar('--accent') || 'black';
      ctx.fillStyle = panel;
      ctx.strokeStyle = accent;
      ctx.lineWidth = 1;
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 4;
      const boxX = x - w/2;
      const boxY = tooltipY - 20;
      const boxH = line3 ? 48 : 36;
      const r = 6;
      ctx.beginPath();
      ctx.moveTo(boxX+r, boxY);
      ctx.lineTo(boxX+w-r, boxY);
      ctx.quadraticCurveTo(boxX+w, boxY, boxX+w, boxY+r);
      ctx.lineTo(boxX+w, boxY+boxH-r);
      ctx.quadraticCurveTo(boxX+w, boxY+boxH, boxX+w-r, boxY+boxH);
      ctx.lineTo(boxX+r, boxY+boxH);
      ctx.quadraticCurveTo(boxX, boxY+boxH, boxX, boxY+boxH-r);
      ctx.lineTo(boxX, boxY+r);
      ctx.quadraticCurveTo(boxX, boxY, boxX+r, boxY);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.fillStyle = accent;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(line1, x, boxY + 10);
      ctx.fillText(line2, x, boxY + 25);
      if(line3) ctx.fillText(line3, x, boxY + 40);
    }

    ctx.restore();
  }
};

// üîí (d√©s)active temporairement zoom/pan/drag de chartjs-zoom
function setZoomSuspended(suspended){
  if(!chart || !chart.options?.plugins?.zoom) return;

  if (suspended) {
    // sauvegarder l'√©tat une seule fois
    if (!chart.$zoomBackup) {
      chart.$zoomBackup = JSON.parse(JSON.stringify(chart.options.plugins.zoom));
    }
    chart.options.plugins.zoom.zoom.wheel.enabled = false;
    chart.options.plugins.zoom.zoom.pinch.enabled = false;
    chart.options.plugins.zoom.zoom.drag.enabled  = false;
    chart.options.plugins.zoom.pan.enabled        = false;
  } else {
    if (chart.$zoomBackup) {
      chart.options.plugins.zoom = JSON.parse(JSON.stringify(chart.$zoomBackup));
    }
  }
  chart.update('none');
}

    
const notesPlugin = {
  id: "notesPlugin",
  afterDatasetsDraw(chart) {
   if (!notesVisible || !notesData.length) return;



    const ctx = chart.ctx;
    const xScale = chart.scales.x;
    const yScale = chart.scales.y;

    if (!xScale || !yScale) return;

    chart.$noteHitZones = [];
    ctx.save();
    ctx.font = "11px sans-serif";
    ctx.textBaseline = "top";

    for (const n of notesData) {
      if (n.status !== "active") continue;
      if (n.type === "avg") continue;

      const x = xScale.getPixelForValue(n.x);
      const y = yScale.getPixelForValue(n.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) continue;

      // MULTI-LIGNES
      const lines = String(n.note || "").split(/\r?\n/);
      const lh = 14;
      const padX = 8;
      const padY = 6;

      let textW = 0;
      for (const l of lines) {
        const w = ctx.measureText(l).width;
        if (w > textW) textW = w;
      }

      const boxW = textW + padX * 2;
      const boxH = lines.length * lh + padY * 2;

      const rx = x + 6;
      const ry = y - boxH - 8;

      // fond couleur compl√®te
      ctx.fillStyle = n.color || "#ff7043";
      ctx.beginPath();
      ctx.roundRect(rx, ry, boxW, boxH, 6);
      ctx.fill();

// üîπ Texte centr√© horizontalement et verticalement
ctx.fillStyle = "#fff";
ctx.textAlign = "center";
ctx.textBaseline = "middle";

for (let i = 0; i < lines.length; i++) {
  const lineY = ry + boxH / 2 + (i - (lines.length - 1) / 2) * lh;
  ctx.fillText(lines[i], rx + boxW / 2, lineY);
}


      // ZONE CLIQUABLE POUR EDIT
      chart.$noteHitZones.push({
        note: n,
        x1: rx,
        x2: rx + boxW,
        y1: ry,
        y2: ry + boxH
      });
    }

    ctx.restore();
  }
};


const avgPlugin = {
  id: "avgPlugin",
  afterDatasetsDraw(chart) {
     
 if (!notesData.length) return;


    const ctx = chart.ctx;
    const xScale = chart.scales.x;
    const yScale = chart.scales.y;

    if (!xScale || !yScale) return;

    chart.$avgHitZones = [];
    ctx.save();
    ctx.font = "12px sans-serif";
    ctx.textBaseline = "middle";

    for (const n of notesData) {
      if (n.type !== "avg" || n.status !== "active") continue;

      const x1 = xScale.getPixelForValue(n.x1);
      const x2 = xScale.getPixelForValue(n.x2);
      const midX = (x1 + x2) / 2;

      // ligne horizontale
      const y = yScale.getPixelForValue(n.avg);
      ctx.strokeStyle = n.color || "#0aa6e8";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x1, y);
      ctx.lineTo(x2, y);
      ctx.stroke();

      // texte
// Texte centr√©
const text = `Valeur moyenne : ${n.avg.toFixed(1)}`;
ctx.font = "13px sans-serif";

// Mesure largeur texte
const textW = ctx.measureText(text).width;

// Taille du cadre
const padX = 10;
const padY = 6;
const boxW = textW + padX * 2;
const boxH = 22 + padY * 2;

// Rectangle
const rx = midX - boxW / 2;
const ry = y - boxH / 2;

ctx.fillStyle = n.color;
ctx.fillRect(rx, ry, boxW, boxH);

// Texte centr√©
ctx.fillStyle = "#fff";
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillText(text, midX, ry + boxH / 2);


      // ZONE CLIQUABLE
chart.$avgHitZones.push({
  note: n,
  x1: rx,
  x2: rx + boxW,
  y1: ry,
  y2: ry + boxH
});

    }
    ctx.restore();
  }
};



     











  async function loadZ3IfAvailable(){
    z3Events = [];
    if (!saMeta) return false;
    const list = JSON.parse(localStorage.getItem("csvFilesList") || "[]");
    const expectedZ = `Z3${saMeta.num}_${saMeta.date}.csv`.toLowerCase();
    const f = list.find(x => String(x.name || "").toLowerCase() === expectedZ);
    if (!f) return false;

    const parsedZ = await loadCSVByFileId(f.id);
    if (!parsedZ || !parsedZ.data || parsedZ.data.length < 1) return false;

    // D√©tection souple des lignes d'en-t√™te
    let headerRowIdx = 0;
    for (let i=0;i<Math.min(5, parsedZ.data.length);i++){
      const row = parsedZ.data[i] || [];
      const joined = row.map(v => String(v||'')).join('|').toLowerCase();
      if (joined.includes('trigger') && (joined.includes('time') || joined.includes('date'))) {
        headerRowIdx = i;
        break;
      }
    }
    const headersZ = parsedZ.data[headerRowIdx];
    const rows = parsedZ.data.slice(headerRowIdx+1);

    // indices colonnes
    const idxDate = headersZ.findIndex(h => String(h||'').toLowerCase().includes('trigger') && String(h||'').toLowerCase().includes('date'));
    const idxTime = headersZ.findIndex(h => String(h||'').toLowerCase().includes('trigger') && String(h||'').toLowerCase().includes('time'));
    let idxMsg  = headersZ.findIndex(h => String(h||'').toLowerCase().includes('message'));
    if (idxMsg === -1) idxMsg = headersZ.findIndex(h => String(h||'').toLowerCase().includes('event'));
let idxAddr = headersZ.findIndex(h => String(h||'').toLowerCase().includes('address'));


    rows.forEach(r => {
      const dateStr = r[idxDate];
      const timeStr = r[idxTime];
      const label = r[idxMsg] || '√âv√©nement';
      if (!dateStr || !timeStr) return;
      // support "20/09/25" ou "2025-09-20"
      let dt;
      if (typeof dateStr === 'string' && dateStr.includes('/')){
        const [d,m,y] = String(dateStr).split('/');
        const iso = `20${y}-${m}-${d}T${String(timeStr)}`;
        dt = new Date(iso);
      }else{
        dt = new Date(`${String(dateStr)}T${String(timeStr)}`);
      }
if (!isNaN(dt.getTime())) {
  let addr = "";
  if (idxAddr >= 0 && r[idxAddr] != null) {
    addr = String(r[idxAddr]).trim();
    if (addr.toLowerCase() === "null" || addr === "undefined") addr = "";
  }
  z3Events.push({
    time: dt,
    label: String(label),
    address: addr
  });
}


    });

    // Afficher le bouton
    const btn = document.getElementById('toggleZ3');
    btn.style.display = 'inline-block';
    return true;
  }

 function drawChart(){
    // üßπ Emp√™che la duplication des √©v√©nements sur le canvas
  const oldCanvas = document.getElementById("myChart");
  if (oldCanvas) {
    const newCanvas = oldCanvas.cloneNode(true); // clone sans √©v√©nements
    oldCanvas.parentNode.replaceChild(newCanvas, oldCanvas);
  }

  // üß† Maintenant on repart proprement sur ce nouveau canvas
  const ctx=document.getElementById('myChart').getContext('2d');

  const allX=csvData.map(r=>r.__sortKey).filter(v=>Number.isFinite(v));
  const minX=Math.min(...allX), maxX=Math.max(...allX);

  // stocker les bornes initiales une seule fois
  if (initialMin === null) initialMin = minX;
  if (initialMax === null) initialMax = maxX;

  const datasets = buildDatasets();

  // Sauvegarder zoom avant destruction
  let prevMin=null, prevMax=null;
  if(chart){
    prevMin = chart.scales.x.min;
    prevMax = chart.scales.x.max;
    chart.destroy();
  }

  chart=new Chart(ctx,{
    type:'line',
    data:{datasets},
    options:{
      devicePixelRatio: 2, //R√©solution canva
      responsive:true,
      maintainAspectRatio:false,
      parsing:false,
      interaction:{mode:'nearest',axis:'x',intersect:false},
      plugins:{
        legend:{
  position:'top',
  labels:{
    usePointStyle:true,
    pointStyle:'rect',
    color:getCSSVar('--text')
  },
  onClick:(e,legendItem)=>{
    const datasetIndex = legendItem.datasetIndex;
    const ds = chart.data.datasets[datasetIndex];

    // ‚úÖ cl√© stable pour m√©moriser la couleur
    const baseLabel = ds.label.replace(" (liss√©)", "");

    const picker = document.getElementById('colorPicker');
    picker.oninput = (ev)=>{
      const newColor = ev.target.value;

      // m√©morisation
      customColors[baseLabel] = newColor;

      // application
      ds.borderColor = newColor;
      ds.backgroundColor = newColor;
      ds.pointBackgroundColor = newColor;
      ds.pointBorderColor = newColor;

      chart.update('none');
    };
    picker.click();
  }
},

        datalabels:{display:false},
        zoom:{
          zoom:{
            wheel:{enabled:true,modifierKey:'ctrl'},
            pinch:{enabled:true},
            drag:{
              enabled:true,
              mode:'x',
              backgroundColor:'rgba(54, 162, 235, 0.1)', // fond semi-transparent
              borderColor:'rgba(54, 162, 235, 0.5)',     // contour visible
              borderWidth:1
            }
          },
          pan:{enabled:true,mode:'x'},
          limits:{ y:{min:'original',max:'original'} }
        }
      },
      tooltip:{
        callbacks:{
          title:(items)=>{
            if(!items?.length) return '';
            const d=new Date(items[0].parsed.x);
            return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
          }
        }
      },
      scales:{
        x:{
          type:'time',
          min: prevMin ?? (Number.isFinite(minX)?minX:undefined),
          max: prevMax ?? (Number.isFinite(maxX)?maxX:undefined),
          time:{
            unit:'hour',
            tooltipFormat:'HH:mm',
            displayFormats:{hour:'HH:mm',minute:'HH:mm'}
          },
          ticks:{
            autoSkip:true,
            callback:(value)=>{
              const d=new Date(value);
              return `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
            }
          }
        },
        y:{title:{display:true,text:'Valeurs'}}
      }
    },
    plugins: [
  ChartDataLabels,
  dayBackgroundPlugin,
  z3LinesPlugin,
  notesPlugin,
  avgPlugin
]


  });

  // === Tous les listeners regroup√©s ===
  const canvas = chart.canvas;

  // auto-load jours au zoom/d√©zoom/pan
canvas.addEventListener('wheel', async (e)=>{
  // üîï pas de zoom/autoLoad pendant drag de note
  if (chart.$draggingNote) { e.preventDefault(); return; }
  if (e.ctrlKey) {
    console.log("D√©tection zoom molette+Ctrl");
    await autoLoadDays(chart);
  }
}, { passive:false });

  canvas.addEventListener('mouseup', async ()=>{
    console.log("D√©tection fin zoom/pan drag");
    await autoLoadDays(chart);
  });

  // gestion survol Z3
  canvas.addEventListener('mousemove', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    chart.$z3Mouse = {x,y};
    chart.update('none');
  });

// === SURVOL NOTES : curseur main ===
canvas.addEventListener("mousemove", (ev) => {
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;
  const zones = chart.$noteHitZones || [];

  let over = false;
  for (const z of zones) {
    if (x >= z.x1 && x <= z.x2 && y >= z.y1 && y <= z.y2) {
      over = true;
      break;
    }
  }
  chart.canvas.style.cursor = over ? "pointer" : "default";
});



   
  canvas.addEventListener('mouseleave', ()=>{
    chart.$z3Mouse = null;
    chart.update('none');
  });


// === CLIC SUR UNE NOTE EXISTANTE ===
canvas.addEventListener("click", (ev) => {
    // üö´ Ne pas interf√©rer si on est en mode ajout de note
  if (chart.$noteMode) return;
  if (!chart) return;
  const zones = chart.$noteHitZones || [];
  if (!zones.length) return;

  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left;
  const y = ev.clientY - rect.top;

  for (const z of zones) {
    if (x >= z.x1 && x <= z.x2 && y >= z.y1 && y <= z.y2) {
      showNotePopup(z.note);
      ev.stopPropagation();
      ev.preventDefault();
      return; // üî• stop tout (emp√™che zoom/pan)
    }
  }
});

   
// === Gestion clic sur une note existante ===
canvas.addEventListener("click", (ev) => {

  // üö´ Si on est en mode ajout de note ‚Üí on sort
  if (chart.$noteMode) return;
  
  // üö´ Si le mode moyenne est inactif, on sort
  if (!avgMode) return;

  ev.stopPropagation();
  ev.preventDefault();

  if (!chart) return;

  const pts = chart.getElementsAtEventForMode(ev, "nearest", { intersect: false }, true);
  if (!pts || !pts.length) {
    showToast("‚ö†Ô∏è Clique sur un point existant.");
    return;
  }

  const el = pts[0];
  const ds = chart.data.datasets[el.datasetIndex];
  const point = ds.data[el.index];
  const curveId = ds.id; // identifiant stable

  // üü¢ Premier clic
  if (avgState === "first") {
    avgStart = { id: curveId, x: point.x };
    avgState = "second";
    showToast(`üü° Premier point s√©lectionn√© sur "${curveId}". Choisis le second.`);
    return;
  }

  // üü¢ Deuxi√®me clic
  if (avgState === "second") {
    if (curveId !== avgStart.id) {
      showToast("‚ùó Les deux points doivent √™tre sur la m√™me courbe.");
      resetAvgCycle();
      return;
    }

    const min = Math.min(avgStart.x, point.x);
    const max = Math.max(avgStart.x, point.x);
    const dataset = chart.data.datasets.find(d => d.id === curveId);
    if (!dataset) {
      showToast("‚ùó Courbe introuvable.");
      resetAvgCycle();
      return;
    }

    const ptsAvg = dataset.data.filter(p => p.x >= min && p.x <= max);
    if (!ptsAvg.length) {
      showToast("‚ùó Aucun point entre ces deux positions.");
      resetAvgCycle();
      return;
    }

    const avg = ptsAvg.reduce((s, p) => s + p.y, 0) / ptsAvg.length;
    createAverageNote(curveId, min, max, avg);

    showToast(`üìê Moyenne : ${avg.toFixed(2)}`);

    // üîπ reset complet imm√©diatement apr√®s affichage
    resetAvgCycle();

  }

  // === D√âTECTION DES NOTES CLASSIQUES ===
  let nearest = null;
  let minDist = 18;

  for (const n of notesData) {
    if (n.status !== "active") continue;
    const x = xScale.getPixelForValue(n.x);
    const y = yScale.getPixelForValue(n.y);
    const d = Math.hypot(x - xClick, y - yClick);
    if (d < minDist) {
      nearest = n;
      minDist = d;
    }
  }

  if (nearest) {
    showNotePopup(nearest);
  }
});


// === DRAG NOTES ===
canvas.addEventListener("mousedown",(ev)=>{
  if (!notesData.length) return;
  const rect = canvas.getBoundingClientRect();
  const xClick = ev.clientX - rect.left;
  const yClick = ev.clientY - rect.top;

  for (const z of chart.$noteHitZones || []) {
    if (
      xClick>=z.x1 && xClick<=z.x2 &&
      yClick>=z.y1 && yClick<=z.y2
    ) {
chart.$draggingNote = z.note;
setZoomSuspended(true); // üß© suspend le zoom/pan pendant le drag
return;

    }
  }
});

canvas.addEventListener("mousemove",(ev)=>{
  if (!chart.$draggingNote) return;
  const rect = canvas.getBoundingClientRect();
  const xPix = ev.clientX-rect.left;
  const yPix = ev.clientY-rect.top;
  const xScale = chart.scales.x;
  const yScale = chart.scales.y;

  chart.$draggingNote.x = xScale.getValueForPixel(xPix);
  chart.$draggingNote.y = yScale.getValueForPixel(yPix);
  chart.$justDragged = true;

  chart.update('none');
});

canvas.addEventListener("mouseup", async () => {
  if (chart.$draggingNote) {
    const n = chart.$draggingNote;
    chart.$draggingNote = null;
    setZoomSuspended(false); // üß© r√©active le zoom/pan une fois l√¢ch√©

    try {
      // üîπ envoi des nouvelles coordonn√©es au script Google
      const resp = await fetch(
        "https://script.google.com/macros/s/AKfycbz9zcweeyv7GpC4ZCLnw57uVvuHEOWEmfbvnLHVaqZ8Php179viedbf7PX8Vmi8HhTX7Q/exec",
        {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: new URLSearchParams({
            status: "update",
            folderId: localStorage.getItem("lastFolderId"),
            csvName: baseFileName,
            createdAt: n.createdAt,
            x: n.x,
            y: n.y,
            color: n.color || colorFromAuthor(n.author || "Anonyme")
          })
        }
      );

      console.log("üì§ Position mise √† jour :", await resp.text());
      showToast("üìç Position mise √† jour !");
    } catch (err) {
      console.error("‚ö†Ô∏è Erreur MAJ position :", err);
      showToast("‚ùå Erreur mise √† jour");
    }
  }
});


 


  // Nettoyage complet du mode moyenne √† chaque redessin
  notesData = notesData.filter(n => n.type !== "avg");
  resetAvgCycle();

// === R√©attacher le listener d‚Äôajout de note sur le nouveau canvas ===
const noteAdder = (ev) => {
  if (!chart || !chart.$noteMode) return;

  const rect = chart.canvas.getBoundingClientRect();
  const xPix = ev.clientX - rect.left;
  const yPix = ev.clientY - rect.top;

  const xScale = chart.scales.x;
  const yScale = chart.scales.y;

  const xValue = xScale.getValueForPixel(xPix);
  const yValue = yScale.getValueForPixel(yPix);
  clickedPoint = { x: xValue, y: yValue };
  chart.$noteMode = false;

  // petit effet visuel
  const ping = document.createElement("div");
  Object.assign(ping.style, {
    position: "absolute",
    left: rect.left + xPix - 10 + "px",
    top: rect.top + yPix - 10 + "px",
    width: "20px",
    height: "20px",
    borderRadius: "50%",
    background: "rgba(255,112,67,0.6)",
    transform: "scale(0.5)",
    opacity: "1",
    pointerEvents: "none",
    zIndex: "2000",
    transition: "transform 0.6s ease-out, opacity 0.8s ease-out"
  });
  document.body.appendChild(ping);
  requestAnimationFrame(() => {
    ping.style.transform = "scale(2)";
    ping.style.opacity = "0";
  });
  setTimeout(() => ping.remove(), 900);

  // ouverture de la popup
  coordsDisplay.textContent = `üìç X: ${new Date(xValue).toLocaleString()} | Y: ${yValue.toFixed(2)}`;
  popup.classList.add("active");
  txt.value = "";
  status.textContent = "";
  txt.focus();
};

// üîÅ rattachement sur le canvas fra√Æchement recr√©√©
chart.canvas.addEventListener("click", noteAdder);

   
  chart.update();
  applyAdaptiveTicks();
   resetAvgCycle();

}




  /* ===================== UI ===================== */
  document.getElementById('backBtn').onclick=()=>window.close();

  // Auto-affichage du graphique d√®s qu'une case Y est coch√©e/d√©coch√©e
document.getElementById("yColumnsContainer").addEventListener("change", () => {
  resetAvgCycle(); // üßπ R√©initialiser le mode moyenne proprement √† chaque changement de courbe
  currentX = document.getElementById('xColumn').value;
  currentY = Array.from(document.querySelectorAll("#yColumnsContainer input:checked")).map(cb => cb.value);
  if (currentY.length) {
    drawChart();
  }
});


  // Ctrl+clic ‚Üí changer la couleur du dataset le plus proche
  const colorPickerEl = document.getElementById('colorPicker');
  document.getElementById('myChart').addEventListener('click', (ev)=>{
    if (!ev.ctrlKey || !chart) return;
    const points = chart.getElementsAtEventForMode(ev, 'nearest', {intersect:false}, true);
    if (!points || !points.length) return;
    const el = points[0];
    const datasetIndex = el.datasetIndex;
    colorPickerEl.oninput = (e)=>{
      const newColor = e.target.value;
      const ds = chart.data.datasets[datasetIndex];
const baseLabel = ds.label.replace(" (liss√©)", "");
customColors[baseLabel] = newColor;
 // m√©morise par label
ds.borderColor = newColor;
ds.backgroundColor = newColor;
ds.pointBackgroundColor = newColor;
ds.pointBorderColor = newColor;

      chart.update('none');
    };
    // ouvrir le color picker
    colorPickerEl.click();
  });

// Reset zoom
document.getElementById('resetZoom').onclick=()=>{
  if(!chart) return;

  // Emp√™cher autoLoadDays de s‚Äôex√©cuter pendant le reset
  chart.$isResetting = true;

  chart.resetZoom();
  chart.options.scales.x.min = initialMin;
  chart.options.scales.x.max = initialMax;
  applyAdaptiveTicks();
  chart.update('none');

  // R√©activer autoLoadDays apr√®s un petit d√©lai
  setTimeout(()=>{ chart.$isResetting = false; }, 200);
};


  // ==== LISSAGE avec m√©morisation ====
  function updateSmoothBtnUI() {
    const btn = document.getElementById("smoothBtn");
    const smooth = localStorage.getItem("smooth") === "1";
    btn.textContent = smooth ? "‚ú® Lissage ON" : "‚ú® Lissage OFF";
    btn.style.background = smooth ? getCSSVar("--accent-darker") : getCSSVar("--accent");
  }
  document.getElementById("smoothBtn").onclick = () => {
    const smooth = localStorage.getItem("smooth") === "1";
    localStorage.setItem("smooth", smooth ? "0" : "1");
    updateSmoothBtnUI();
    if (currentY.length) drawChart();
  };

  // Bouton ON/OFF Z3
  document.getElementById('toggleZ3').onclick = () => {
    z3Visible = !z3Visible;
    const btn = document.getElementById('toggleZ3');
    btn.textContent = z3Visible ? 'üö® √âv√©nements ON' : 'üö® √âv√©nements OFF';
    btn.style.background = z3Visible ? getCSSVar('--accent-darker') : getCSSVar('--accent');
    if (chart) chart.update('none');
  };

  // üóíÔ∏è Bouton ON/OFF Notes
document.getElementById('toggleNotes').onclick = () => {
  notesVisible = !notesVisible;
  const btn = document.getElementById('toggleNotes');
  btn.textContent = notesVisible ? 'üóíÔ∏è Notes ON' : 'üóíÔ∏è Notes OFF';
  btn.style.background = notesVisible ? getCSSVar('--accent-darker') : getCSSVar('--accent');
  if (chart) chart.update('none');
};



    
// === Parasite filter ON/OFF ===
document.getElementById("filterParasites").onclick = () => {
  parasiteFilterEnabled = !parasiteFilterEnabled;

  const btn = document.getElementById("filterParasites");
  btn.textContent = parasiteFilterEnabled ? "üßπ Parasites ON" : "üßπ Parasites OFF";
  btn.style.background = parasiteFilterEnabled
    ? getCSSVar("--accent-darker")
    : getCSSVar("--accent");

  if (currentY.length) drawChart();
};



/* ===================== EXTEND / PAN ===================== */
async function loadDayIfAvailable(yyyymmdd){
  if(loadedDays.has(yyyymmdd)) return true;

  const list = JSON.parse(localStorage.getItem("csvFilesList") || "[]");
  if(!saMeta) return false;

  // === CSV principal (SA) ===
  const name=`SA${saMeta.num}_${yyyymmdd}.csv`;
  const f=list.find(x=>x.name===name);
  if(f){
    const parsed=await loadCSVByFileId(f.id);
    if(parsed){
      const rows=buildObjectsFromParsedResults(parsed,headers);
      enrichRowsWithDate(rows,yyyymmdd);
      csvData=csvData.concat(rows);
      loadedDays.add(yyyymmdd);
    }
  }

  // === CSV √©v√©nements Z3 associ√© ===
  const nameZ = `Z3${saMeta.num}_${yyyymmdd}.csv`;
  const fz = list.find(x => String(x.name||"").toLowerCase() === nameZ.toLowerCase());
  if(fz){
    const parsedZ = await loadCSVByFileId(fz.id);
    if(parsedZ && parsedZ.data && parsedZ.data.length > 1){
      let headerRowIdx = 0;
      for (let i=0;i<Math.min(5, parsedZ.data.length);i++){
        const row = parsedZ.data[i] || [];
        const joined = row.map(v => String(v||'')).join('|').toLowerCase();
        if (joined.includes('trigger') && (joined.includes('time') || joined.includes('date'))) {
          headerRowIdx = i;
          break;
        }
      }
      const headersZ = parsedZ.data[headerRowIdx];
      const rowsZ = parsedZ.data.slice(headerRowIdx+1);

      const idxDate = headersZ.findIndex(h => String(h||'').toLowerCase().includes('date'));
      const idxTime = headersZ.findIndex(h => String(h||'').toLowerCase().includes('time'));
      let idxMsg  = headersZ.findIndex(h => String(h||'').toLowerCase().includes('message'));
      if (idxMsg === -1) idxMsg = headersZ.findIndex(h => String(h||'').toLowerCase().includes('event'));
      const idxAddr = headersZ.findIndex(h => String(h||'').toLowerCase().includes('address'));

      rowsZ.forEach(r=>{
        const dateStr = r[idxDate], timeStr = r[idxTime];
        if(!dateStr || !timeStr) return;
        let dt;
        if (typeof dateStr === 'string' && dateStr.includes('/')){
          const [d,m,y] = String(dateStr).split('/');
          const iso = `20${y}-${m}-${d}T${String(timeStr)}`;
          dt = new Date(iso);
        }else{
          dt = new Date(`${String(dateStr)}T${String(timeStr)}`);
        }
        if(!isNaN(dt.getTime())){
          let addr = "";
          if(idxAddr>=0 && r[idxAddr]!=null){
            addr = String(r[idxAddr]).trim();
            if(addr.toLowerCase()==="null"||addr==="undefined") addr="";
          }
          z3Events.push({
            time: dt,
            label: String(r[idxMsg]||'√âv√©nement'),
            address: addr
          });
        }
      });

      // Afficher le bouton Z3 si dispo
      const btn=document.getElementById('toggleZ3');
      btn.style.display='inline-block';
    }
  }

  return true;
}


  async function panAndLoad(direction){
    if(!chart || !saMeta) return;

    const sc = chart.scales.x;
    const oneDay = 86400000;
    const currMin = (chart.options.scales.x.min!=null)? chart.options.scales.x.min : sc.min;
    const currMax = (chart.options.scales.x.max!=null)? chart.options.scales.x.max : sc.max;
    const targetMin = currMin + direction*oneDay;
    const targetMax = currMax + direction*oneDay;

    const targetDate = shiftDate(saMeta.date, direction);
    const loaded = await loadDayIfAvailable(targetDate);

    if (loaded) {
      csvData.sort((a,b)=>(a.__sortKey||0)-(b.__sortKey||0));
      if (currentY.length) drawChart();
      saMeta.date = targetDate;
      chart.options.scales.x.min = targetMin;
      chart.options.scales.x.max = targetMax;
      chart.options.scales.y.min = undefined;
      chart.options.scales.y.max = undefined;
      chart.update('none');
      applyAdaptiveTicks();
      // Recharger les Z3 de la nouvelle date
      await loadZ3IfAvailable();
    } else {
      const d=`${targetDate.slice(6,8)}/${targetDate.slice(4,6)}/${targetDate.slice(0,4)}`;
      alert(`Aucun fichier disponible pour la date ${d}`);
      return;
    }
  }


  async function extendDays(direction,days){
    if(!saMeta) return;
    for(let i=1;i<=days;i++){
      const target=shiftDate(saMeta.date,direction>0?i:-i);
      await loadDayIfAvailable(target);
    }
    csvData.sort((a,b)=>(a.__sortKey||0)-(b.__sortKey||0));
    if(currentY.length) drawChart();
    await loadZ3IfAvailable();
  }

  let modalResolve=null, modalDirection=0;
  function openDayModal(initial,dir){
    modalDirection=dir;
    const m=document.getElementById('dayModal');
    const inp=document.getElementById('dayCount');
    inp.value=initial||1; m.style.display='block'; inp.focus(); inp.select();
    return new Promise(res=>{modalResolve=res;});
  }
  function closeDayModal(){document.getElementById('dayModal').style.display='none'; if(modalResolve){modalResolve(null); modalResolve=null;}}
  document.getElementById('confirmDay').onclick=()=>{
    const n=parseInt(document.getElementById('dayCount').value,10);
    document.getElementById('dayModal').style.display='none';
    if(modalResolve){modalResolve(isNaN(n)?null:{n,dir:modalDirection}); modalResolve=null;}
  };


/* ===================== AUTO LOAD DAYS (zoom/pan) ===================== */
async function autoLoadDays(chart){
  // üö´ si on est en train de faire un reset ‚Üí on sort direct
  if(chart.$isResetting) return;
  if(!saMeta) return;

  const xScale = chart.scales.x;
  const min = xScale.min, max = xScale.max;

  const d0 = new Date(min);
  const d1 = new Date(max);

  // Mise √† z√©ro heure (‚ö†Ô∏è pas de limite veille/lendemain)
  d0.setHours(0,0,0,0);
  d1.setHours(0,0,0,0);

  let newData = false;

  for(let d=new Date(d0); d<=d1; d.setDate(d.getDate()+1)){
    const ymd = d.getFullYear()
                + String(d.getMonth()+1).padStart(2,"0")
                + String(d.getDate()).padStart(2,"0");
    console.log("Tentative chargement", ymd);
    const loaded = await loadDayIfAvailable(ymd);
    if (loaded) {
      console.log("‚úÖ Jour charg√©", ymd);
      newData = true;
    }
  }

  if(newData){
    // Trier toutes les donn√©es CSV
    csvData.sort((a,b)=>(a.__sortKey||0)-(b.__sortKey||0));

    // Recharger les datasets visibles
    if(currentY.length){
      chart.data.datasets = buildDatasets();
      chart.update('none');
      applyAdaptiveTicks();
    }

    // üîî Recharger les √©v√©nements Z3 li√©s
    await loadZ3IfAvailable();
    if(z3Visible && chart) chart.update('none');
  }
}



/* ===================== EXPORT PDF ===================== */
document.getElementById('exportPDF').onclick = () => {
    showSpinner();

    setTimeout(() => {

        // üîπ Nettoyage des emojis uniquement
        function stripEmojis(str) {
            return str.replace(/[\p{Extended_Pictographic}]/gu, "");
        }

        if (!chart) { alert("Aucun graphique √† exporter."); hideSpinner(); return; }

        let jsPDFConstructor = null;
        if (window.jspdf && window.jspdf.jsPDF) jsPDFConstructor = window.jspdf.jsPDF;
        else if (window.jsPDF) jsPDFConstructor = window.jsPDF;

        if (!jsPDFConstructor) { alert("jsPDF n‚Äôest pas charg√© !"); hideSpinner(); return; }

        const pdf = new jsPDFConstructor({ orientation: 'landscape' });
        const pageWidth = pdf.internal.pageSize.getWidth();

        // üî∏ Nom CSV brut
        const csvName = (getParam('fileName') || '').split('\\').pop() || '';

        // üî∏ Titre initial nettoy√©
        let titleText = stripEmojis(csvName).trim();
        let pdfFileName = csvName.replace(/\.csv$/i, '.pdf');

        /* ============ BRANCHE Z ============ */
        if (csvName.startsWith("Z")) {
            const matchZ = csvName.match(/^Z\d+(\d{2})_(\d{8})/);
            if (matchZ) {
                const xx = parseInt(matchZ[1], 10).toString();
                const d = matchZ[2];
                titleText = `Historique S√©choir ${xx} - ${d.slice(6, 8)}/${d.slice(4, 6)}/${d.slice(0, 4)}`;
            }
        }

        /* ============ BRANCHE SA ============ */
        else {
            const match = csvName.match(/^SA(\d+)_([0-9]{8})/);
            if (match) {
                const num = parseInt(match[1], 10);
                const d = match[2];

                let folderEl = document.getElementById("currentFolderName");
                let folderName = folderEl ? stripEmojis(folderEl.textContent.trim()) : "SansNom";

                const dateFR = `${d.slice(6, 8)}/${d.slice(4, 6)}/${d.slice(0, 4)}`;
                const numTxt = num > 0 ? `S√©choir ${num}` : "";

                // üî∏ Titre final
                titleText = `${folderName} ‚Äì ${numTxt} ‚Äì ${dateFR}`.trim();

                // üî∏ Nom PDF safe
                const safeFolder = folderName
                    .replace(/[<>:"/\\|?*]/g, "_")
                    .replace(/\s+/g, "_");

                pdfFileName = num > 0
                    ? `${safeFolder}_S${String(num).padStart(2, "0")}_${d}.pdf`
                    : `${safeFolder}_${d}.pdf`;

                // üî∏ M√©tadonn√©es
                pdf.setProperties({
                    title: `Courbes ‚Äì ${folderName}${numTxt ? " ‚Äì " + numTxt : ""} ‚Äì ${dateFR}`,
                    subject: 'Export graphique CSV S√©choir',
                    author: 'SMES Explorer'
                });
            }
        }

        /* ============ TITRE + STYLE ============ */
        const danger = getCSSVar('--danger') || '#d84315';
        const { r, g, b } = hexToRgb(danger);
        const pdfSafeGrey = { r: 50, g: 50, b: 50 };

        pdf.setFontSize(14);
        pdf.setTextColor(r, g, b);

        const lines = pdf.splitTextToSize(titleText, pageWidth - 20);
        const titleY = 12;
        pdf.text(lines, 14, titleY);

        /* ============ GRAPHIQUE HD x3 ============ */
        const canvas = chart.canvas;
        const pageHeight = pdf.internal.pageSize.getHeight();
        const scale = Math.min(
            (pageWidth - 20) / canvas.width,
            (pageHeight - 60) / canvas.height
        );

        const chartX = (pageWidth - canvas.width * scale) / 2;
        const chartY = titleY + 8 + lines.length * 5;

// Canvas HD
const hd = document.createElement("canvas");
hd.width = canvas.width * 3;
hd.height = canvas.height * 3;

const hctx = hd.getContext("2d");

// üîπ Ajout obligatoire : fond blanc
hctx.fillStyle = "#ffffff";
hctx.fillRect(0, 0, hd.width, hd.height);

hctx.scale(3, 3);
hctx.imageSmoothingEnabled = false;

// copie du graphe
hctx.drawImage(canvas, 0, 0);

const imgData = hd.toDataURL("image/jpeg", 0.92);
 


pdf.addImage(
    imgData,
    "JPEG",
    chartX,
    chartY,
    canvas.width * scale,
    canvas.height * scale
);

        /* ============ LABELS DE DATE ============ */
        const dateLabels = document.getElementById('dateLabels')?.textContent || "";
        if (dateLabels) {
            pdf.setFontSize(10);
            pdf.setTextColor(pdfSafeGrey.r, pdfSafeGrey.g, pdfSafeGrey.b);

            const wrapped = pdf.splitTextToSize(dateLabels, pageWidth - 20);
            pdf.text(
                wrapped,
                pageWidth / 2,
                chartY + canvas.height * scale + 15,
                { align: "center" }
            );
        }

        /* ============ SAUVEGARDE PDF ============ */
        pdf.save(pdfFileName);

        /* ============ FIN ============ */
        hideSpinner();

    }, 20); // spinner visible imm√©diatement
};

  /* ===================== INIT ===================== */
  (async function(){
    setTheme(localStorage.getItem("selectedTheme")||"orange");

    // initialiser √©tat lissage
    if (!localStorage.getItem("smooth")) localStorage.setItem("smooth","0");
    document.getElementById("smoothBtn").style.display="inline-block";
    document.getElementById("filterParasites").style.display = "inline-block";
    document.getElementById("avgModeBtn").style.display="inline-block";

// ======================= MODE MOYENNE =======================

document.getElementById("avgModeBtn").onclick = () => {
  if (!chart) return;

  avgMode = true;       // <--- activation
  avgState = "first";
  avgStart = null;

  highlightAvgBtn(true);
  showToast("üü¢ S√©lectionne le PREMIER point sur une courbe.");
};



    

    updateSmoothBtnUI();

    await loadCSVFromDrive();

// === üóíÔ∏è CHARGEMENT AUTOMATIQUE DES NOTES ASSOCI√âES ===
try {
  if (!currentFolderId || !baseFileName) {
    console.warn("‚ö†Ô∏è Impossible de charger les notes (folderId ou baseFileName manquant)");
  } else {
    const list = JSON.parse(localStorage.getItem("csvFilesList") || "[]");
    const expectedJson = baseFileName.replace(/\.csv$/i, ".json").toLowerCase();
    const noteFile = list.find(
      x =>
        String(x.name || "").toLowerCase() === expectedJson &&
        Array.isArray(x.parents) &&
        x.parents.includes(currentFolderId)
    );

    if (noteFile) {
      console.log("üì• Fichier de notes d√©tect√© :", noteFile.name, noteFile.id);
      const url = `https://smes21540.netlify.app/.netlify/functions/drive?id=${noteFile.id}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Erreur HTTP " + res.status);
      const jsonText = await res.text();
      const notes = JSON.parse(jsonText);
      console.log("‚úÖ Notes charg√©es :", notes);

      // üîß Conversion et nettoyage des donn√©es avant affichage
notesData = notes.map(n => ({
  id: n.id || crypto.randomUUID(),
  x: Number(n.x),
  y: Number(n.y),
  note: n.note,      // ‚Üê c‚Äôest CE champ
  author: n.author,
  createdAt: n.createdAt,
  status: n.status || "active",
  color: n.color || colorFromAuthor(n.author || "Anonyme")
}));




      // üßπ On garde uniquement les notes valides
      notesData = notesData.filter(n => Number.isFinite(n.x) && Number.isFinite(n.y));

      console.log("üìä Notes pr√™tes √† afficher :", notesData);

// üîò Affiche le bouton d‚Äôactivation des notes
const btnNotes = document.getElementById('toggleNotes');
btnNotes.style.display = 'inline-block';
btnNotes.textContent = 'üóíÔ∏è Notes ON';
btnNotes.style.background = getCSSVar('--accent-darker');

      
// üß© Forcer l‚Äôaffichage diff√©r√© des notes, une fois le graphe cr√©√©
const waitForChart = setInterval(() => {
  if (chart) {
    console.log("üé® Graphe pr√™t ‚Üí affichage des notes");
    chart.update("none");
    clearInterval(waitForChart);
  }
}, 500);

    } else {
      console.log("üóíÔ∏è Aucun fichier de notes trouv√© pour", baseFileName);
    }
  }
} catch (err) {
  console.error("‚ö†Ô∏è Erreur lors du chargement des notes :", err);
}



    
    // Dessiner si des Y sont d√©j√† m√©moris√©s ? (on attend le clic utilisateur)
    // -> rien, on laisse l'utilisateur cocher.

    // Charger Z3 (si dispo) mais masquer par d√©faut
    await loadZ3IfAvailable();
    z3Visible = false;
    const btn = document.getElementById('toggleZ3');
    if (btn.style.display !== 'none') {
      btn.textContent = 'üö® √âv√©nements OFF';
    }

    // aide zoom temporaire
    document.getElementById('zoomInfo').style.display='block';
    setTimeout(()=>{document.getElementById('zoomInfo').style.display='none';},5000);

    // zone libell√©s de dates sous le graphe
    if(!document.getElementById('dateLabels')){
      const dl=document.createElement("div");
      dl.id="dateLabels";
      dl.style.textAlign="center";
      dl.style.marginTop="10px";
      dl.style.fontSize="13px";
      dl.style.color=getCSSVar('--text');
      document.querySelector(".graph-wrapper").after(dl);
    }
  })();



    
  </script>



<!-- === BLOC AJOUT/ENVOI DE NOTES === -->
<div id="noteButton" title="Ajouter une note sur cette courbe">üóíÔ∏è</div>

<div id="notePopup">
  <div class="note-content">
    <h3>Nouvelle note</h3>
    <p id="noteCoords" style="font-size:12px;color:gray;"></p>
<input id="noteAuthor" type="text" placeholder="Votre nom (facultatif)" style="width:100%;padding:6px;margin-bottom:6px;">
<label style="font-size:12px;display:block;margin:6px 0;">Couleur :
  <input type="color" id="noteColor" value="#ff7043">
</label>
<textarea id="noteText" placeholder="√âcrire une remarque..." style="width:100%;height:120px;"></textarea>


    <div class="note-actions">
      <button id="saveNoteBtn">Enregistrer</button>
      <button id="cancelNoteBtn">Annuler</button>
    </div>
    <div id="noteStatus"></div>
  </div>
</div>

<script>
const noteBtn = document.getElementById("noteButton");
const popup = document.getElementById("notePopup");
const txt = document.getElementById("noteText");
const status = document.getElementById("noteStatus");
const coordsDisplay = document.getElementById("noteCoords");
const authorInput = document.getElementById("noteAuthor");

let clickedPoint = null;

// üü¢ √âtape 1 : clic sur le bouton "üóíÔ∏è" ‚Üí activer mode s√©lection avec bulle
noteBtn.addEventListener("click", () => {
  if (!chart) {
    showToast("‚ö†Ô∏è Aucune courbe charg√©e !");
    return;
  }

  chart.$noteMode = true;
  showToast("üñ±Ô∏è Clique sur un point de la courbe pour ajouter ta note", 5000);
});







// üü¢ √âtape 3 : annuler la saisie
document.getElementById("cancelNoteBtn").addEventListener("click", () => {
  popup.classList.remove("active");
});

document.getElementById("saveNoteBtn").addEventListener("click", async () => {
  const content = txt.value.trim();
  if (!content) {
    status.textContent = "‚ö†Ô∏è Note vide.";
    return;
  }
  status.textContent = "üíæ Envoi en cours...";

  try {
    const createdAt = new Date().toISOString();
    const pickedColor =
      document.getElementById("noteColor")?.value ||
      colorFromAuthor(authorInput.value || "Anonyme");

    // üî• Un SEUL ID unique
    const newId = crypto.randomUUID();

    const payload = {
      id: newId,
      csvName: baseFileName || "inconnu.csv",
      fileId: baseFileId,
      folderId: localStorage.getItem("lastFolderId") || "",
      author: authorInput.value || "Anonyme",
      note: content,
      x: clickedPoint ? clickedPoint.x : "",
      y: clickedPoint ? clickedPoint.y : "",
      createdAt,
      status: "active",
      dossier: currentFolderPath || "",
      color: pickedColor
    };

    console.log("üì§ Donn√©es envoy√©es au Script Google :", payload);

    // === IP utilisateur ===
    let ip = "inconnue";
    try {
      const ipRes = await fetch("https://api.ipify.org?format=json");
      if (ipRes.ok) {
        const ipData = await ipRes.json();
        ip = ipData.ip || "inconnue";
      }
    } catch {}

    // === Envoi Google Script
    await fetch(
      "https://script.google.com/macros/s/AKfycbz9zcweeyv7GpC4ZCLnw57uVvuHEOWEmfbvnLHVaqZ8Php179viedbf7PX8Vmi8HhTX7Q/exec",
      {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          ...payload,
          ip
        })
      }
    );

    // === AJOUT LOCAL (IMPORTANT)
    notesData.push({
      ...payload,
      color: pickedColor
    });

    // Fermer popup + redraw
    popup.classList.remove("active");
    chart.update("none");
    showToast("üóíÔ∏è Note enregistr√©e !");
  } catch (e) {
    console.error("Erreur cr√©ation note", e);
    status.textContent = "‚ùå Erreur r√©seau.";
  }
});


/* ===================== MOYENNES EN NOTES ===================== */

function createAverageNote(label, x1, x2, avg) {
  const id = crypto.randomUUID();
  const createdAt = new Date().toISOString();

  const noteObj = {
    id,
    type: "avg",
    dataset: label,   // <‚Äî l‚Äôidentit√© de la courbe
    x1,
    x2,
    avg,
    color: "#0aa6e8",
    createdAt,
    status: "active"
  };

  notesData.push(noteObj);
  if (chart) chart.update("none");
}








  
</script>


<script>
// === üßæ Popup d'affichage / suppression d'une note ===
function showNotePopup(note) {
  const popup = document.createElement("div");
  popup.style = `
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.5); display: flex;
    align-items: center; justify-content: center; z-index: 4000;
  `;

  const dateStr = note.createdAt
    ? new Date(note.createdAt).toLocaleString()
    : "Date inconnue";

popup.innerHTML = `
  <div style="background:#fff;padding:20px;border-radius:10px;max-width:420px;">
    <h3>üóíÔ∏è Note</h3>
    <p><strong>Auteur :</strong> ${note.author || "Anonyme"}</p>
    <p><strong>Cr√©√©e le :</strong> ${dateStr}</p>
    <label style="display:block;margin:8px 0;font-size:12px;">Couleur :
      <input type="color" id="noteColorEdit" value="${note.color || colorFromAuthor(note.author || "Anonyme")}">
    </label>
    <hr>
    <p style="white-space:pre-wrap;">${note.text || note.note}</p>
    <div style="text-align:right;margin-top:10px;display:flex;gap:6px;justify-content:flex-end;">
      <button id="updateNoteBtn" style="background:#1976d2;color:white;border:none;border-radius:6px;padding:6px 12px;">Mettre √† jour</button>
      <button id="deleteNoteBtn" style="background:#d84315;color:white;border:none;border-radius:6px;padding:6px 12px;">Supprimer</button>
      <button id="closeNoteBtn">Fermer</button>
    </div>
  </div>
`;


  document.body.appendChild(popup);

// Mise √† jour de la couleur
popup.querySelector("#updateNoteBtn").onclick = async () => {
  const newColor = popup.querySelector("#noteColorEdit").value || note.color;
  try {
    // MAJ locale
    note.color = newColor;
    if (chart) chart.update("none");

    // MAJ serveur
    const resp = await fetch(
      "https://script.google.com/macros/s/AKfycbz9zcweeyv7GpC4ZCLnw57uVvuHEOWEmfbvnLHVaqZ8Php179viedbf7PX8Vmi8HhTX7Q/exec",
      {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          status: "update",
          folderId: localStorage.getItem("lastFolderId"),
          csvName: baseFileName,
          createdAt: note.createdAt,
          x: note.x,
          y: note.y,
          color: newColor
        })
      }
    );
    console.log("Update color:", await resp.text());
    showToast("üé® Couleur mise √† jour");
  } catch (e) {
    showToast("‚ö†Ô∏è Erreur maj couleur : " + e.message);
  }
};

  
  // üîπ Fermer la popup
  popup.querySelector("#closeNoteBtn").onclick = () => popup.remove();

  // üîπ Supprimer (status ‚Üí inactive)
  popup.querySelector("#deleteNoteBtn").onclick = async () => {
showConfirm("Confirmer la suppression de cette note ?", async () => {
  try {
    // üí• effet rouge visuel
    showPointEffect(note.x, note.y, "rgba(220,0,0,0.6)");

    const response = await fetch(
      "https://script.google.com/macros/s/AKfycbz9zcweeyv7GpC4ZCLnw57uVvuHEOWEmfbvnLHVaqZ8Php179viedbf7PX8Vmi8HhTX7Q/exec",
      {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
body: new URLSearchParams({
  id: note.id || "",                             // üÜî identifiant pour mise √† jour
  folderId: localStorage.getItem("lastFolderId"), // ‚úÖ on revient au bon dossier !
  csvName: baseFileName,
  note: note.text || note.note,
  x: note.x,
  y: note.y,
  status: "inactive"
})



      }
    );

    console.log("R√©ponse suppression :", await response.text());

    note.status = "inactive";
    popup.remove();

    notesData = notesData.filter(n => n.status === "active");
    if (chart) chart.update("none");
  } catch (err) {
    showToast("Erreur suppression : " + err.message);
  }
});

  };
}


// === üì¢ Petit syst√®me de notification flottante (remplace alert) ===
function showToast(message, duration = 4000) {
  const old = document.querySelector(".toast-message");
  if (old) old.remove();

  const toast = document.createElement("div");
  toast.className = "toast-message";
  toast.textContent = message;

  Object.assign(toast.style, {
    position: "fixed",
    bottom: "80px",
    right: "20px",
    background: "var(--accent)",
    color: "#fff",
    padding: "12px 16px",
    borderRadius: "8px",
    boxShadow: "0 4px 12px rgba(0,0,0,0.3)",
    zIndex: "3000",
    fontWeight: "bold",
    opacity: "0",
    transition: "opacity 0.3s, transform 0.3s",
    transform: "translateY(20px)"
  });

  document.body.appendChild(toast);
  requestAnimationFrame(() => {
    toast.style.opacity = "1";
    toast.style.transform = "translateY(0)";
  });

  setTimeout(() => {
    toast.style.opacity = "0";
    toast.style.transform = "translateY(20px)";
    setTimeout(() => toast.remove(), 300);
  }, duration);
}

  // === üí´ Petit effet visuel (cr√©ation / suppression) ===
function showPointEffect(xValue, yValue, color = "rgba(255,112,67,0.6)", duration = 900) {
  const xScale = chart.scales.x;
  const yScale = chart.scales.y;
  const xPix = xScale.getPixelForValue(xValue);
  const yPix = yScale.getPixelForValue(yValue);
  const rect = chart.canvas.getBoundingClientRect();

  const effect = document.createElement("div");
  Object.assign(effect.style, {
    position: "absolute",
    left: rect.left + xPix - 10 + "px",
    top: rect.top + yPix - 10 + "px",
    width: "20px",
    height: "20px",
    borderRadius: "50%",
    background: color,
    transform: "scale(0.5)",
    opacity: "1",
    pointerEvents: "none",
    zIndex: "2000",
    transition: "transform 0.6s ease-out, opacity 0.8s ease-out"
  });

  document.body.appendChild(effect);
  requestAnimationFrame(() => {
    effect.style.transform = "scale(2)";
    effect.style.opacity = "0";
  });
  setTimeout(() => effect.remove(), duration);
}


// === ü™∂ Popup de confirmation styl√©e ===
function showConfirm(message, onConfirm) {
  const overlay = document.createElement("div");
  overlay.style = `
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.4);
    display: flex; align-items: center; justify-content: center;
    z-index: 5000;
  `;

  const box = document.createElement("div");
  box.style = `
    background: white;
    border-radius: 10px;
    padding: 20px 24px;
    max-width: 350px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    text-align: center;
    font-family: sans-serif;
    animation: popIn 0.25s ease-out;
  `;
  box.innerHTML = `
    <p style="margin-bottom:20px;font-weight:bold;">${message}</p>
    <div style="display:flex;justify-content:center;gap:10px;">
      <button id="cancelBtn" style="
        padding:8px 14px;border:none;border-radius:6px;
        background:#ccc;cursor:pointer;">Annuler</button>
      <button id="okBtn" style="
        padding:8px 14px;border:none;border-radius:6px;
        background:#d84315;color:white;cursor:pointer;">Confirmer</button>
    </div>
  `;

  overlay.appendChild(box);
  document.body.appendChild(overlay);

  box.querySelector("#cancelBtn").onclick = () => overlay.remove();
  box.querySelector("#okBtn").onclick = () => {
    overlay.remove();
    if (onConfirm) onConfirm();
  };
}

  
</script>



  
  
</body>
</html>















